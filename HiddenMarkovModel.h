#pragma once
#include <string>  
#include <unordered_map>
#include <map>
#include <vector>
#include <set>
/**
* The <c>HiddenMarkovModel</c> class represents hidden markov model and give methods
* for calculating sequence of states by Viterbi and Forward-Backward algorithms
*/

class HiddenMarkovModel {
private:
	std::vector<std::vector<double>> emissionMatrix;           /**< matrix of emission probabilities in log scale*/
	std::vector<std::vector<double>> transitionMatrix;         /**< matrix of transition probabilities in log scale*/
	std::vector<double> initialVector;                         /**< vector of initial probabilities in log scale*/
	std::set<std::string> states;					           /**< set of states labels*/
	std::set<std::string> observations;				           /**< set of observation labels*/
	std::unordered_map<std::string,int> stateToNumber;		   /**< map from state label to its code number */
	std::unordered_map<std::string,int> observationToNumber;   /**< map from observation label to its code number */
	std::vector<std::string> numberToState;					   /**< map from code number to state label */
	std::vector<std::string> numberToObservation;			   /**< map from code number to observation label */
	int numberOfStates;										   /**< number of states in the model*/
	int numberOfObservations;								   /**<number of possible observations in the model*/ 

	/** 
	*  Class for tracking paths generated by Viterbi algorithm
	*/
	class Track {
	public: 
		std::vector<int> path;    /**< most likely path that ends with the last state in specific time slice of hmm simulation*/
		double probabilityOfPath; /**< probability of the path in log scale*/

		/**
		* Initializes a newly created <c>Track</c> object with empty path and zero probability (-infinity in log scale)
		*/
		Track();

		/**
		*	Initializes a newly created <c>Track</c> object with specified path and log of its probability
		*	@param path
		*	@param probabilityOfPath
		*/
		Track(std::vector<int>& path, double probabilityOfPath); 
	};

	/** 
	* Returns log(a + b) given log(a) and log(a), where log denotes natural logarithm. 
	* @param loga equals to log(a)
	* @param logb equals to log(b)
	*/
	double logSum(double loga, double logb); 

	/**
	* Checks if the specified vector is stochastic (sum = 1).
	* @param probabilityVector vector to be checked
	* @return <c>true</c> if the given vector is stochastic, else <c>false</c>
	*/
	bool isStochastic(const std::vector<double>& probabilityVector);

	/**
	* Checks if the specified matrix is stochastic (sum in rows = 1).
	* @param probabilityMatrix matrix to be checked
	* @return <c>true</c> if the given matrix is stochastic, else <c>false</c>
	*/
	bool isStochastic(const std::vector<std::vector<double>>& probabilityMatrix);


public:
	/**
	* Initializes a newly created <c>HiddenMarkovModel</c> object
	* @param transitionProbabilities transition probabilities between pairs of hidden states 
	* @param emissionProbabilities   emission probabilities between hidden states and  possible observations
	* @param initialProbabilities initial probabilities of states
	* 
	* @todo change map to unordered_map for better performance 
	*/

	HiddenMarkovModel(const std::map<std::pair<std::string,std::string>,double>& transitionProbabilities, 
					  const std::map<std::pair<std::string,std::string>,double>& emissionProbabilities,
					  const std::map<std::string, double>& initialProbabilities
					 );

	/**
	* Implements Viterbi algorithm
	* @param observationSequenceLabels   sequence of observations labels
	* @return viterbi path
	*/
	std::vector<std::string> calculateViterbiPath(const std::vector<std::string>& observationSequenceLabels);

	/**
	* Implements Forward-Backward algorithm
	* @param observationSequenceLabels   sequence of observations labels
	* @return sequence of states
	*/
	std::vector<std::string> calculateSequenceByForwardBackward(const std::vector<std::string>& observationSequenceLabels);

	~HiddenMarkovModel(void);
};